/*
    This file is part of Magnum.

    Copyright © 2010, 2011, 2012, 2013, 2014, 2015, 2016, 2017, 2018
              Vladimír Vondruš <mosra@centrum.cz>

    Permission is hereby granted, free of charge, to any person obtaining a
    copy of this software and associated documentation files (the "Software"),
    to deal in the Software without restriction, including without limitation
    the rights to use, copy, modify, merge, publish, distribute, sublicense,
    and/or sell copies of the Software, and to permit persons to whom the
    Software is furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included
    in all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
    THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
    DEALINGS IN THE SOFTWARE.
*/

namespace Magnum {
/** @page examples-primitives Primitives
@brief Importing mesh data, 3D transformations and input handling.

@tableofcontents
@m_footernavigation

@image html primitives.png

This example shows how to create indexed meshes from imported data and do some
basic user interaction, introducing these new features:

-   Interleaving vertex data and compressing indices for better performance.
-   Basic 3D transformations and perspective projection.
-   Mouse event handling.

This example displays colored cube with ability to change its color and rotate
it using mouse.

@m_div{m-button m-primary} <a href="http://magnum.graphics/showcase/primitives/">@m_div{m-big}Live web demo @m_enddiv @m_div{m-small} uses WebAssembly & WebGL @m_enddiv </a> @m_enddiv

@section examples-primitives-setup Setting up and preparing the mesh

This example makes use of imported 3D mesh data, processes them and renders
using a Phong shader.

@dontinclude primitives/PrimitivesExample.cpp
@skip #include
@until Trade/MeshData3D

@note Magnum does not provide any global "include everything" header, but
    instead keeps the headers small with little dependencies. It may be a bit
    annoying at first, but helps to keep your build times short. See
    @ref compilation-speedup for more information.

In our class we now need two buffers instead of one. Additionaly for user
interactivity we need to implement mouse event handlers and store
transformation/projection @ref Math::Matrix4 "matrices" plus current
@ref Math::Color3 "color".

@skip class PrimitivesExample
@until };

Because we are displaying 3D scene, we need to enable depth test to have the
cube rendered in proper Z-order. Enabling face culling is not needed for proper
rendering, but it will speed things up as only front-facing faces will be
rendered.

@skip PrimitivesExample::PrimitivesExample
@until GL::Renderer::enable(GL::Renderer::Feature::FaceCulling

We now use the pre-made @ref Primitives::cubeSolid() "cube primitive" and
create a mesh from it. The mesh is indexed and contains position and normal
data. As said earlier, interleaving the data gives us best memory access
performance. We can do it by hand as in the previous example, but using
@ref MeshTools::interleave() is much more convenient. We upload the interleaved
data directly to vertex buffer.

@skip Trade::MeshData3D
@until _vertexBuffer.setData(

Why do we need indexed mesh and what it actually is? In most meshes the
same vertex data are shared among more than one vertex, even a simple square
consists of two triangles sharing two adjacent vertices. To save precious GPU
memory, the mesh can be indexed, i.e. containing buffer with unique vertex data
and index buffer telling which data belong to which vertex. The indices are by
default just 32-bit integers. But most meshes don't need full 32-bit range to
index vertex data --- our mesh has only 36 unique vertices, thus even the
smallest possible 8-bit range is large enough. @ref MeshTools::compressIndices()
again does all the boring work for us --- it checks index range and creates
an array consisting of @ref UnsignedByte, @ref UnsignedShort or @ref UnsignedInt
indices based on that.

@skip Containers::Array<char>
@until _indexBuffer.

Everything is now ready for configuring the mesh. We set the primitive type,
index count, add our vertex buffer and specify the index buffer. The `indexStart`
and `indexEnd` parameters are purely optional, but they might improve memory
access performance on desktop GL as the GPU will know what subset of vertex
data are used.

@skip _mesh.setPrimitive
@until .setIndexBuffer

We now specify the initial transformation, color and projection. See
@ref matrix-vector and @ref transformations for more thorough introduction to
transformations.

@skip _transformation =
@until }
@until }

@section examples-primitives-rendering Rendering

In the draw event we clear the framebuffer (don't forget to clear also depth
buffer), set transformation, normal and projection matrices and all material
parameters and draw the mesh.

@skip void PrimitivesExample::drawEvent
@until }
@until }
@until }

@section examples-primitives-events Mouse event handling

Event handling is also nothing complicated, on every click (press + release) we
change color hue to some other and on mouse drag we rotate the object based on
relative mouse position to previous event.

@skip void PrimitivesExample::mousePressEvent
@until }
@until }
@until }
@until }
@until }
@until }
@until }

The main function is just the macro call, as previously.

@code{.cpp}
MAGNUM_APPLICATION_MAIN(PrimitivesExample)
@endcode

Once again, this code displays a grid primitive:

@code{.cpp}
			_transformation = Matrix4::rotationX(30.0_degf)*
				Matrix4::rotationY(40.0_degf);
			_color = Color3::fromHsv(35.0_degf, 1.0f, 1.0f);

			_projection = Matrix4::perspectiveProjection(35.0_degf, Vector2{ GL::defaultFramebuffer.viewport().size() }.aspectRatio(), 0.01f, 100.0f)*
				Matrix4::translation(Vector3::zAxis(-10.0f));
			{
				Trade::MeshData3D cube = Primitives::grid3DWireframe({ 5,3 });
				_vertexBuffer = GL::Buffer{};
				_indexBuffer = GL::Buffer{};
				_vertexBuffer.setData(cube.positions(0), GL::BufferUsage::StaticDraw);
				Containers::Array<char> indexData;
				MeshIndexType indexType;
				UnsignedInt indexStart, indexEnd;
				std::tie(indexData, indexType, indexStart, indexEnd) = MeshTools::compressIndices(cube.indices());
				_indexBuffer.setData(indexData, GL::BufferUsage::StaticDraw);
				// do not use normals at all when rendering lines
				_mesh.setPrimitive(cube.primitive())
					.setCount(cube.indices().size())
					.addVertexBuffer(_vertexBuffer, 0, Shaders::Flat3D::Position{})
					.setIndexBuffer(_indexBuffer, 0, indexType, indexStart, indexEnd);
			}
@endcode

@section examples-primitives-compilation Compilation

Compilation is pretty straigtforward. We now need some additional libraries,
like `MeshTools` and `Primitives`, everything else is the same as previously:

@dontinclude primitives/CMakeLists.txt
@skip find_package(Magnum REQUIRED
@until Magnum::Shaders)

If you like, you may include the required lib files manually to project without using CMake. This list will work for Windows OS, it was tested in Visual Studio environment (THE ORDER MAY MATTER!):

CorradePluginManager-d.lib;
MagnumSceneGraph-d.lib;
MagnumPrimitives-d.lib;
MagnumTrade-d.lib;
MagnumMeshTools-d.lib;
MagnumSDL2Application-d.lib;
MagnumShaders-d.lib;
MagnumDebugTools-d.lib;
Magnum-d.lib;
MagnumGL-d.lib;
SDL2-staticd.lib;
CorradeUtility-d.lib;
opengl32.lib;
glu32.lib;
winmm.lib;
imm32.lib;
version.lib;
kernel32.lib;
user32.lib;
gdi32.lib;
winspool.lib;
comdlg32.lib;
advapi32.lib;
shell32.lib;
ole32.lib;
oleaut32.lib;
uuid.lib;
odbc32.lib;
odbccp32.lib

Make sure that you have compiled SDL2 library (and constructed/configured a SDL2 sources project using CMAKE), and built Magnum setting -WITH-SDL2APPLICATION key.

You can now try using another primitive from @ref Primitives namespace or
render the mesh with different shader from @ref Shaders namespace. The full
file content is linked below. Full source code is also available in the
[magnum-examples GitHub repository](https://github.com/mosra/magnum-examples/tree/master/src/primitives).

-   @ref primitives/CMakeLists.txt "CMakeLists.txt"
-   @ref primitives/PrimitivesExample.cpp "PrimitivesExample.cpp"

The [ports branch](https://github.com/mosra/magnum-examples/tree/ports/src/primitives)
contains additional patches for @ref CORRADE_TARGET_IOS "iOS",
@ref CORRADE_TARGET_ANDROID "Android" and @ref CORRADE_TARGET_EMSCRIPTEN "Emscripten"
support that aren't present in `master` in order to keep the example code as
simple as possible.

@example primitives/CMakeLists.txt @m_examplenavigation{examples-primitives,primitives/} @m_footernavigation
@example primitives/PrimitivesExample.cpp @m_examplenavigation{examples-primitives,primitives/} @m_footernavigation

*/
}
